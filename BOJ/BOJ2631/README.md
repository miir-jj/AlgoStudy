# BOJ 2629번 [줄세우기](https://www.acmicpc.net/problem/2631)

## 🌈 풀이 후기
- LIS 알고리즘을 활용하여 푼 문제였습니다.
- 이전에 비슷한 문제를 풀 때의 기억을 살려서 풀었습니다.
- 기존에는 LIS의 길이만 구할 수 있는 알고리즘을 알고 있었는데, 가장 긴 수열을 구하는 방법도 알고 싶어서
  학습 후 구현해본 코드도 추가합니다!
## 👩‍🏫 문제 풀이
binarySearch를 이용한 LIS알고리즘을 이용했습니다.
dp리스트를 두고,
 1. 리스트의 맨 마지막 원소보다 현재 값이 클 경우
  - 리스트 맨 마지막에 바로 추가
 2. 리스트의 마지막 원소보다 값이 작을 경우
  - 앞의 원소들에서 넣을 자리를 찾아줌(binarysearch이용)

-> dp리스트의 크기가 LIS의 길이가 됨<br>
-> LIS의 요소를 구하는 방법은 index배열을 따로 두어 각 요소가 dp에 저장된 인덱스를 저장하고,<br>
index 배열을 뒤부터 살피며 dp의 길이부터 하나씩 줄여나가며 해당값과 일치하는 원소를 거꾸로 출력하면 된다.


 #### 변수
- n(int): 입력받는 수
- dp(linkedlist): LIS의 길이를 구하기 위한 리스트
- l(int): dp리스트의 길이(LIS의 길이)
 #### 핵심 코드

```
for(int i=0;i<N;i++) {
    n=Integer.parseInt(br.readLine());
    l=dp.size();
    if(dp.get(l-1)<n) { //리스트의 가장 마지막 원소보다 클 경우
        dp.add(n); // 바로추가
    }else { //마지막 원소보다 작을 경우
        int index=binarySearch(dp,n)+1; //이분탐색으로는 들어갈 자리 앞에 인덱스가 구해지므로 +1해줌
        dp.remove(index);//해당자리 숫자 지우고
        dp.add(index, n);//현재 숫자를  추가함
    }
}
System.out.println(N-(dp.size()-1))//LIS에 해당하는 원소 빼고 나머지를 옮기면 되므로 전체 길이에서 뺀 숫자를 리턴(0제외)
```
